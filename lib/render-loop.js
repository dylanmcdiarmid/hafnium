var StateMap = require("./state-map.js")
var raf = require('raf')
var create = require('virtual-dom/create-element')
var diff = require('virtual-dom/diff')
var patch = require('virtual-dom/patch')

var RenderLoop = function(parentElement, initialState, renderFn, opts) {
  opts = opts || {}
  if (!(this instanceof RenderLoop)) {
    return new RenderLoop(parentElement, initialState, renderFn, opts)
  }
  var defaultOpts = {
    beforeDiff: null,
    beforePatch: null,
  }
  // Set defaults
  for (var k in defaultOpts) {
    if (typeof(opts[k]) === 'undefined') {
      opts[k] = defaultOpts[k]
    }
  }
  this.opts = opts
  this.parentElement = parentElement
  this.state = new StateMap(this, initialState)
  this.renderFn = renderFn
  this.previousTree = null
  this.isRendering = false
  // The virtual representation of the current render
  this.currentTree = this.renderFn(this.state)
  // Current render is the rendered virtual dom
  // It is used during the patch operation to turn the patches
  // generated by diff and is added to the dom immediately when
  // instantiating RenderLoop
  this.currentRender = create(this.currentTree)
  // Caches keys changed during a single update loop
  // which will be passed to any beforeRedraw or afterRedraw event
  this.changedKeys = []
  parentElement.appendChild(this.currentRender)
  return this
}

RenderLoop.prototype.update = function update(changedKey) {
  var self = this
  if (this.changedKeys.indexOf(changedKey) < 0) {
    this.changedKeys.push(changedKey)
  }
  // If you are getting this error, it oftentimes meant
  if (this.isRendering) {
    throw new Error("Call to update during a render.")
  }
  if (!this.redrawScheduled) {
    this.redrawScheduled = true
    raf(function scheduledRedraw() { self.redraw.call(self) })
  }
}

RenderLoop.prototype.onBeforeDiff = function onBeforeDiff(v) {
  console.log("this", this)
  this.opts.beforeDiff = v
}

RenderLoop.prototype.onBeforePatch = function onBeforePatch(v) {
  this.opts.beforePatch = v
}

RenderLoop.prototype.redraw = function redraw() {
  this.redrawScheduled = false
  this.isRendering = true
  var cancelRedraw = false
  var cancelPatch = false
  // Call the user supplied render function, passing it state
  // We expect to get a virtual tree back (such as what's generated by virtual-dom/virtual-hyperscript)
  if (this.opts.beforeDiff) {
    cancelRedraw = this.opts.beforeDiff(this.changedKeys)
  }
  if (!cancelRedraw) {
    try {
      var newTree = this.renderFn(this.state)
    }
    catch (e) {
      console.error("Error with render function during redraw: ", e.stack)
      this.isRendering = false
      return false
    }
    var patches = diff(this.currentTree, newTree)
    if (this.opts.beforePatch) {
      cancelPatch = this.opts.beforePatch({
        changed: this.changedKeys, 
        patches: patches,
        newTree: newTree,
        currentRender: this.currentRender,
        currentTree: this.currentTree})
    }
    if (!cancelPatch) {
      this.currentRender = patch(this.currentRender, patches)
      this.currentTree = newTree
    }
  }
  this.isRendering = false
  this.changedKeys = []
}

module.exports = RenderLoop
