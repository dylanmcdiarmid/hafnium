var StateMap = require("./state-map.js")
var raf = require('raf')
var create = require('virtual-dom/create-element')
var diff = require('virtual-dom/diff')
var patch = require('virtual-dom/patch')

var RenderLoop = function(parentElement, initialState, renderFn) {
  if (!(this instanceof RenderLoop)) {
    return new RenderLoop(parentElement, initialState, renderFn)
  }
  this.parentElement = parentElement
  this.state = new StateMap(this, initialState)
  this.renderFn = renderFn
  this.previousTree = null
  this.isRendering = false
  // The virtual representation of the current render
  this.currentTree = this.renderFn(this.state)
  // Current render is the rendered virtual dom
  // It is used during the patch operation to turn the patches
  // generated by diff and is added to the dom immediately when
  // instantiating RenderLoop
  this.currentRender = create(this.currentTree)
  parentElement.appendChild(this.currentRender)
  return this
}

RenderLoop.prototype.update = function() {
  var self = this
  // If you are getting this error, it oftentimes meant
  if (this.isRendering) {
    throw new Error("Call to update during a render.")
  }
  if (!this.redrawScheduled) {
    this.redrawScheduled = true
    raf(function scheduledRedraw() { self.redraw.call(self) })
  }
}

RenderLoop.prototype.redraw = function() {
  this.redrawScheduled = false
  this.isRendering = true
  // Call the user supplied render function, passing it state
  // We expect to get a virtual tree back (such as what's generated by virtual-dom/virtual-hyperscript)
  try {
    var newTree = this.renderFn(this.state)
  }
  catch (e) {
    console.error("Error with render function during redraw: ", e.stack)
    this.isRendering = false
    return false
  }
  var patches = diff(this.currentTree, newTree)
  this.currentRender = patch(this.currentRender, patches)
  this.currentTree = newTree
  this.isRendering = false
}

module.exports = RenderLoop
